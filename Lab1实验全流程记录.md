# 阶段1

## 问题

1. 使用了条件变量加互斥锁来等待新任务到来，但这是错误的，原因是刚开始开发的时候 没有意识到Worker和协调器是运行在两个不同进程中的（这点让我找了很久的bug，刚开始我是使用全局变量共享一些数据的，但是进程间内存是独立的）
2. 并且没有考虑到一个机器宕机后，reduce任务无法发给其他机器继续执行的问题（因为在协调器中没有记录mapper生成的中间结果，而是把中间结果存在了任务中，一个机器从任务队列取出后，任务队列就没有这个任务了，如果执行这个任务的机器宕机了，此任务就丢失了）。
3. 使用的是一个map任务完成后立即创建一个reduce任务（当时认为这种方法可以有着更好的响应处理速度，但是后来想了想，执行map任务和reduce任务分阶段与部分阶段的数量都是一致的，因此这种方法并不能提高处理速度，并且分阶段更好管理与容错），一方面这与论文中描述的map-reduce模型不符，另一方面这增加了容错的复杂性

- 解决方案：在协调器中记录mapper生成的中间结果，待所有map任务都完成后，再创建reduce任务，将等待逻辑直接改为睡眠

# 阶段2

## 问题：

1. 过不了最基础的测试（测试脚本中的第一个）
2. 出现了空指针问题
3. crash测试和indexer测试失败



## 解决方案及原因：

1. 改变了阶段一的代码后，在一处设计处出现了问题，此代码在Coordinator.go文件的processTaskResult函数中，我在缓存中间结果的时候，直接把map生成的中间结果存在了一个任务列表中代码如下:
```go
c.Intermediates[task.Id] = task.MiddleData
```
这种操作会让一个Reducer处理本应该属于别的Reducer任务的中间结果，从而使得过不了测评,应该改为
```go
// 首先将任务的中间结果存入 Intermediates 中
for idx, filename := range task.MiddleData {
    c.Intermediates[idx] = append(c.Intermediates[idx], filename)
}
```
这样就可以让对应Reducer只处理本该由它处理的中间结果。


2. 原因：批量替换log的时候 把log.Fatal给注释了，导致程序在运行到这行的时候，会直接退出，导致空指针异常。
