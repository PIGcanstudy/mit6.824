# 阶段1

## 问题

1. 使用了条件变量加互斥锁来等待新任务到来，但这是错误的，原因是刚开始开发的时候 没有意识到Worker和协调器是运行在两个不同进程中的（这点让我找了很久的bug，刚开始我是使用全局变量共享一些数据的，但是进程间内存是独立的）
2. 并且没有考虑到一个机器宕机后，reduce任务无法发给其他机器继续执行的问题（因为在协调器中没有记录mapper生成的中间结果，而是把中间结果存在了任务中，一个机器从任务队列取出后，任务队列就没有这个任务了，如果执行这个任务的机器宕机了，此任务就丢失了）。
3. 使用的是一个map任务完成后立即创建一个reduce任务（当时认为这种方法可以有着更好的响应处理速度，但是后来想了想，执行map任务和reduce任务分阶段与部分阶段的数量都是一致的，因此这种方法并不能提高处理速度，并且分阶段更好管理与容错），一方面这与论文中描述的map-reduce模型不符，另一方面这增加了容错的复杂性

- 解决方案：在协调器中记录mapper生成的中间结果，待所有map任务都完成后，再创建reduce任务，将等待逻辑直接改为睡眠

## 阶段2

